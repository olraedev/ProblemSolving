#include <iostream>
using namespace std;

// 테트로미노

// 시간복잡도 
// 1. Backtracking 
// 2. DFS (거리 4짜리 DFS) 
// --> 모든 점을 접근해보는 시간 = O(N^2) = 500 x 500 = 250,000
// --> 모든 점에서 거리 4짜리 DFS (4^4 --> 아주 대충) = 600 (nPr) 
// 3. Tshape --> O(1)

/*
5 5
1 2 3 4 5
5 4 3 2 1
2 3 4 5 6
6 5 4 3 2
1 2 1 2 1
*/

/*
4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
*/

int n, m; // n : 세로크기,  m : 가로크기 
int MAP[500][500]; // MAP 최대크기 = 500
int visited[500][500];
int sum = 0; // 누적합
int cnt = 0; 
int ans = -2134567890;

int ydir[] = { 0, 0, 1, -1 };
int xdir[] = { 1, -1, 0, 0 };

// T방향배열
// 0 : ㅗ
// 1 : ㅏ 
// 2 : ㅓ
// 3 : ㅜ
int tydir[4][4] = {
    {0, 0, -1, 0},
    {0, 1, 1, 2},
    {0, -1, 0, 1},
    {0, 0, 0, 1}
};
int txdir[4][4] = {
    {0, 1, 1, 2},
    {0, 0, 1, 0},
    {0, 1, 1, 1},
    {0, 1, 2, 1}
};

// (y,x)위치에서 T자 모양 4개를 다 만들어볼 함수
void tshape(int y, int x) {
    // T로는 4개의 모양을 만들어볼수 있죠 
    for (int i = 0; i < 4; i++) {
        int s = 0; 
        // 각 모양에 대해 4개에 대한 방향배열로 값을 구해봄 
        for (int j = 0; j < 4; j++) {
            int ny = y + tydir[i][j];
            int nx = x + txdir[i][j]; 
            // 방향배열 썼으니까 -> 범위체크 
            // 만약 여기서는 범위가 벗어나면 -> 이 모양은 만들 수 없다!
            // 다음 모양을 만들어보기 시작 
            if (ny < 0 || nx < 0 || ny >= n || nx >= m)
                break; 
            // 이 부분까지의 합은 구해야함 
            s += MAP[ny][nx]; 
        }
        // ---- break 를 안만났다 -> 해당 모양을 만들수 있었다!
        // T자 모양에 대한 정답 갱신을 해봅니다 
        if (s > ans)
            ans = s; 
    }
}


void dfs(int y, int x) {
    // **옵션 기저조건 
    // --> 4개의 연결된 테트로미노를 만들었다면 --> 더 가볼필요 없다!
    if (cnt == 4) {
        // 지금 여기까지 왔을때의 누적합이 최대값이면 -> 갱신 
        if (sum > ans)
            ans = sum; 

        // 돌아가라!
        return; 
    }

    // 재귀 구성
    // 상하좌우 방향으로 뻗어나가볼것. 
    for (int i = 0; i < 4; i++) {
        int ny = y + ydir[i]; 
        int nx = x + xdir[i]; 
        // 방향배열을 사용할때에는 최우선순위 체크 -> 범위체크
        if (ny < 0 || nx < 0 || ny >= n || nx >= m)
            continue;
        // 다음 위치 이미 방문했다면 -> continue
        if (visited[ny][nx] == 1)
            continue;

        // ------여기까지 왔다-------
        // 다음 연결될 블록을 찾았다1 
        // 여기서 계속 또 들어가봐야 함 
        // 이 점을 기준으로 탐색 시작! 
            // 1. 갔던곳 다시 돌아가보지 않도록 ->  방문 기록 
        visited[ny][nx] = 1;
        // 2. 합 처리
        sum += MAP[ny][nx];
        // 3. 몇개의 블록을 봤는가? 
        cnt++;

        dfs(ny, nx);

        // *BACKTRACKING 구성
        // (i, j)위치에서 모든 4칸짜리를 탐색하고 나면 -> 다음 칸으로 이동 
        // 지금 여기에서 기록했던거 싹~다 초기화 
        // 1. 방문 해제
        visited[ny][nx] = 0;
        // 2. 합 차감
        sum -= MAP[ny][nx];
        // 3. 블록 사용 차감
        cnt--;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // input 
    cin >> n >> m;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < m; j++)
            cin >> MAP[i][j]; 
    
    // 모든 칸에서 한번씩
    // 1. 거리 4개짜리 DFS를 돌려보면서 누적합을 구하고, 최대값 갱신 
    // 2. T모양은 따로 방향배열 만들어서 처리를 해줄거예요 .
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            // 이 점을 기준으로 탐색 시작! 
            // 1. 갔던곳 다시 돌아가보지 않도록 ->  방문 기록 
            visited[i][j] = 1; 
            // 2. 합 처리
            sum += MAP[i][j]; 
            // 3. 몇개의 블록을 봤는가? 
            cnt++; 

            dfs(i, j); 

            // *BACKTRACKING 구성
            // (i, j)위치에서 모든 4칸짜리를 탐색하고 나면 -> 다음 칸으로 이동 
            // 지금 여기에서 기록했던거 싹~다 초기화 
            // 1. 방문 해제
            visited[i][j] = 0; 
            // 2. 합 차감
            sum -= MAP[i][j]; 
            // 3. 블록 사용 차감
            cnt--;

            //---------------------------------------------
            // T자를 제외한 모든 도형 상태의 누적합을 구했음. (i,j 위치 시작했을때)
            // T자 처리
            tshape(i, j); 

        }
    }
    cout << ans;
}